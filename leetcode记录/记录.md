1. 两数之和

   给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** 的那 **两个** 整数，并返回它们的数组下标。

   ​	题目解读：输入：nums = [2,7,11,15], target = 9
   ​	输出：[0,1]
   ​	解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

   ```
   思路：
   dic[数值]=索引
   对列表进行迭代，如果目标值减去当前元素的值得到的值在字典里面，则满足加法条件，返回
   dict[差值]的数值，就是索引，加上当前减数的索引共同返回。否则将dic[数值]=索引进行执行。
   ```

   代码：

   ```
   
   class Solution(object):
       def twoSum(self, nums, target):
           """
           :type nums: List[int]
           :type target: int
           :rtype: List[int]
           """
           dic_nums={}
           for i , val in enumerate(nums):
               #如果找到匹配的元素，返回字典中的下标和数组中的下标
               if target-val in dic_nums:
                   return [dic_nums[target-val],i]
               dic_nums[nums[i]]=i
   ```

2. 整数翻转

   给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。

   如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

   ```
   输入：x = 123
   输出：321
   ```

   ```
   思路：
   比较垃圾的思路是不考虑溢出，转str再转int
   ```

   ```
   代码   if可以合并
   class Solution:
       def reverse(self, x: int) -> int:
           if x>0:
               y=str(x)
               y=int(y[::-1])
               if y<2**31:
                   return(y)
               else :
                   return 0
           else:
               y=str(0-x)
               y=int(y[::-1])
           
               if 0-y>=0-2**31:
                   return(0-y)
               else:
                   return 0
   ```

3. 回文判断

   ```
   class Solution:
       def isPalindrome(self, x: int) -> bool:
           if x<0 or(x%10==0 and x!=0):
               #如果x小于零或者是x的末尾数是0就可以直接返回假
               return False
           revertedNummber=0
           while x>revertedNummber:
               revertedNummber=revertedNummber*10+x%10 #取末尾数
               x=x//10 #对10进行整除，
   
           return x==revertedNummber or x ==revertedNummber//10
           
   ```

4. 罗马数字

   ```
   class Solution:
       def romanToInt(self, s: str) -> int:
           Roman2Int = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}
           #建立对应字典
           Int = 0 #数值0
           for index in range(len(s)-1):
               if Roman2Int[s[index]] < Roman2Int[s[index + 1]]:
                   #IV 1，5 代表4
                   Int =Int- Roman2Int[s[index]]
               else:
                   Int =Int+ Roman2Int[s[index]]
           return Int + Roman2Int[s[-1]]
                  
   优化if结构
    
   class Solution:
       def romanToInt(self, s: str) -> int:
           Roman2Int = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}
           #建立对应字典
           Int = 0 #数值0
           for index in range(len(s)-1):
               Int=Int-Roman2Int[s[index]] if Roman2Int[s[index]] < Roman2Int[s[index + 1]] else Int+ Roman2Int[s[index]]
           return Int + Roman2Int[s[-1]]
   ```

5. 最大公共前缀

   ```
   编写一个函数来查找字符串数组中的最长公共前缀。
   
   如果不存在公共前缀，返回空字符串 ""。
   ```

   利用python的max()和min()，在Python里字符串是可以比较的，按照ascII值排，举例abb， aba，abac，最大为abb，最小为aba。所以只需要比较最大最小的公共前缀就是整个数组的公共前缀

   

   **a-z：97-122，A-Z：65-90，0-9：48-57。**

   ```
   class Solution:
       def longestCommonPrefix(self, strs: List[str]) -> str:
           if not strs: return ""
           s1=min(strs)
           s2=max(strs)
   
           for i,x in enumerate(s1):
               if x!=s2[i]:
                   return s2[:i]
           return s1
   ```

6. 有效地括号

   给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

   有效字符串需满足：

   左括号必须用相同类型的右括号闭合。
   左括号必须以正确的顺序闭合。




   ```
   class Solution:
       def isValid(self, s: str) -> bool:
           while '{}' in s or '()' in s or '[]' in s:
               s=s.replace('{}','')
               s=s.replace('[]','')
               s=s.replace('()','')
           return s==''
   ```

7. 合并非递归链表

```

#非递归算法：迭代法
        p = ListNode(-1)#定义一个新的空间
        prev = p 
        while l1 and l2:
            if l1.val > l2.val:
                prev.next = l2
                l2 = l2.next
            else:
                prev.next = l1
                l1 = l1.next
            prev = prev.next
        prev.next = l1 if l1 is not None else l2
        return p.next     
```

8. 去重，非递减列表

   ```
   #两个索引，一个跑，一个追
   #本题采用双指针方法
   class Solution:
       def removeDuplicates(self, nums: List[int]) -> int:
           n=len(nums)
           j=0
           for i in range(1,n):
               if nums[i]!=nums[j]:
                   j=j+1
                   nums[j]=nums[i]
           return j+1
   ```

9. 列表删除指定值

   ```
   class Solution:
       def removeElement(self, nums: List[int], val: int) -> int:
           n=len(nums)
           j=0
           for i in range(n):
               if nums[i]!=val:
                   nums[j]=nums[i]
                   j=j+1
           return j
           
   class Solution:
     def removeElement(self,nums,val):
        p = 0
        q = 0
        while (q<len(nums)):
          if nums[q] == val:
             q += 1
          else:
             nums[p] = nums[q]
             p += 1
             q += 1
         print(nums[0:p])
         return len(nums[0:p])
   
   ```

   