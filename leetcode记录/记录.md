1. 两数之和

   给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** 的那 **两个** 整数，并返回它们的数组下标。

   ​	题目解读：输入：nums = [2,7,11,15], target = 9
   ​	输出：[0,1]
   ​	解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

   ```
   思路：
   dic[数值]=索引
   对列表进行迭代，如果目标值减去当前元素的值得到的值在字典里面，则满足加法条件，返回
   dict[差值]的数值，就是索引，加上当前减数的索引共同返回。否则将dic[数值]=索引进行执行。
   ```

   代码：

   ```
   
   class Solution(object):
       def twoSum(self, nums, target):
           """
           :type nums: List[int]
           :type target: int
           :rtype: List[int]
           """
           dic_nums={}
           for i , val in enumerate(nums):
               #如果找到匹配的元素，返回字典中的下标和数组中的下标
               if target-val in dic_nums:
                   return [dic_nums[target-val],i]
               dic_nums[nums[i]]=i
   ```

2. 整数翻转

   给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。

   如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

   ```
   输入：x = 123
   输出：321
   ```

   ```
   思路：
   比较垃圾的思路是不考虑溢出，转str再转int
   ```

   ```
   代码   if可以合并
   class Solution:
       def reverse(self, x: int) -> int:
           if x>0:
               y=str(x)
               y=int(y[::-1])
               if y<2**31:
                   return(y)
               else :
                   return 0
           else:
               y=str(0-x)
               y=int(y[::-1])
           
               if 0-y>=0-2**31:
                   return(0-y)
               else:
                   return 0
   ```

3. 回文判断
